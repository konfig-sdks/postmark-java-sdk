/*
 * Postmark API
 * Postmark makes sending and receiving email incredibly easy. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.InboundSearchResponse;
import java.time.LocalDate;
import com.konfigthis.client.model.OutboundSearchResponse;
import com.konfigthis.client.model.StandardPostmarkResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class MessagesApiApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MessagesApiApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public MessagesApiApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        if (apiClient.getServerToken() == null) {
            throw new IllegalArgumentException("\"X-Postmark-Server-Token\" is required but no API key was provided. Please set \"X-Postmark-Server-Token\" with ApiClient#setServerToken(String).");
        }
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call getAllClicksCall(Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound/clicks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (recipient != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recipient", recipient));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (clientName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("client_name", clientName));
        }

        if (clientCompany != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("client_company", clientCompany));
        }

        if (clientFamily != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("client_family", clientFamily));
        }

        if (osName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("os_name", osName));
        }

        if (osFamily != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("os_family", osFamily));
        }

        if (osCompany != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("os_company", osCompany));
        }

        if (platform != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("platform", platform));
        }

        if (country != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("country", country));
        }

        if (region != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("region", region));
        }

        if (city != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("city", city));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "serverToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAllClicksValidateBeforeCall(Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling getAllClicks(Async)");
        }

        // verify the required parameter 'offset' is set
        if (offset == null) {
            throw new ApiException("Missing the required parameter 'offset' when calling getAllClicks(Async)");
        }

        return getAllClicksCall(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, _callback);

    }


    private ApiResponse<Object> getAllClicksWithHttpInfo(Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city) throws ApiException {
        okhttp3.Call localVarCall = getAllClicksValidateBeforeCall(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getAllClicksAsync(Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAllClicksValidateBeforeCall(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetAllClicksRequestBuilder {
        private final Integer count;
        private final Integer offset;
        private String recipient;
        private String tag;
        private String clientName;
        private String clientCompany;
        private String clientFamily;
        private String osName;
        private String osFamily;
        private String osCompany;
        private String platform;
        private String country;
        private String region;
        private String city;

        private GetAllClicksRequestBuilder(Integer count, Integer offset) {
            this.count = count;
            this.offset = offset;
        }

        /**
         * Set recipient
         * @param recipient Filter by To, Cc, Bcc (optional)
         * @return GetAllClicksRequestBuilder
         */
        public GetAllClicksRequestBuilder recipient(String recipient) {
            this.recipient = recipient;
            return this;
        }
        
        /**
         * Set tag
         * @param tag Filter by tag (optional)
         * @return GetAllClicksRequestBuilder
         */
        public GetAllClicksRequestBuilder tag(String tag) {
            this.tag = tag;
            return this;
        }
        
        /**
         * Set clientName
         * @param clientName Filter by client name, i.e. Outlook, Gmail (optional)
         * @return GetAllClicksRequestBuilder
         */
        public GetAllClicksRequestBuilder clientName(String clientName) {
            this.clientName = clientName;
            return this;
        }
        
        /**
         * Set clientCompany
         * @param clientCompany Filter by company, i.e. Microsoft, Apple, Google (optional)
         * @return GetAllClicksRequestBuilder
         */
        public GetAllClicksRequestBuilder clientCompany(String clientCompany) {
            this.clientCompany = clientCompany;
            return this;
        }
        
        /**
         * Set clientFamily
         * @param clientFamily Filter by client family, i.e. OS X, Chrome (optional)
         * @return GetAllClicksRequestBuilder
         */
        public GetAllClicksRequestBuilder clientFamily(String clientFamily) {
            this.clientFamily = clientFamily;
            return this;
        }
        
        /**
         * Set osName
         * @param osName Filter by full OS name and specific version, i.e. OS X 10.9 Mavericks, Windows 7 (optional)
         * @return GetAllClicksRequestBuilder
         */
        public GetAllClicksRequestBuilder osName(String osName) {
            this.osName = osName;
            return this;
        }
        
        /**
         * Set osFamily
         * @param osFamily Filter by kind of OS used without specific version, i.e. OS X, Windows (optional)
         * @return GetAllClicksRequestBuilder
         */
        public GetAllClicksRequestBuilder osFamily(String osFamily) {
            this.osFamily = osFamily;
            return this;
        }
        
        /**
         * Set osCompany
         * @param osCompany Filter by company which produced the OS, i.e. Apple Computer, Inc., Microsoft Corporation (optional)
         * @return GetAllClicksRequestBuilder
         */
        public GetAllClicksRequestBuilder osCompany(String osCompany) {
            this.osCompany = osCompany;
            return this;
        }
        
        /**
         * Set platform
         * @param platform Filter by platform, i.e. webmail, desktop, mobile (optional)
         * @return GetAllClicksRequestBuilder
         */
        public GetAllClicksRequestBuilder platform(String platform) {
            this.platform = platform;
            return this;
        }
        
        /**
         * Set country
         * @param country Filter by country messages were opened in, i.e. Denmark, Russia (optional)
         * @return GetAllClicksRequestBuilder
         */
        public GetAllClicksRequestBuilder country(String country) {
            this.country = country;
            return this;
        }
        
        /**
         * Set region
         * @param region Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
         * @return GetAllClicksRequestBuilder
         */
        public GetAllClicksRequestBuilder region(String region) {
            this.region = region;
            return this;
        }
        
        /**
         * Set city
         * @param city Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
         * @return GetAllClicksRequestBuilder
         */
        public GetAllClicksRequestBuilder city(String city) {
            this.city = city;
            return this;
        }
        
        /**
         * Build call for getAllClicks
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getAllClicksCall(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, _callback);
        }


        /**
         * Execute getAllClicks request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = getAllClicksWithHttpInfo(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getAllClicks request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return getAllClicksWithHttpInfo(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city);
        }

        /**
         * Execute getAllClicks request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return getAllClicksAsync(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, _callback);
        }
    }

    /**
     * Clicks for a all messages
     * 
     * @param count Number of message clicks to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @return GetAllClicksRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public GetAllClicksRequestBuilder getAllClicks(Integer count, Integer offset) throws IllegalArgumentException {
        if (count == null) throw new IllegalArgumentException("\"count\" is required but got null");
        if (offset == null) throw new IllegalArgumentException("\"offset\" is required but got null");
        return new GetAllClicksRequestBuilder(count, offset);
    }
    private okhttp3.Call getInboundMessageDetailsCall(String messageid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/inbound/{messageid}/details"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "serverToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getInboundMessageDetailsValidateBeforeCall(String messageid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling getInboundMessageDetails(Async)");
        }

        return getInboundMessageDetailsCall(messageid, _callback);

    }


    private ApiResponse<Object> getInboundMessageDetailsWithHttpInfo(String messageid) throws ApiException {
        okhttp3.Call localVarCall = getInboundMessageDetailsValidateBeforeCall(messageid, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getInboundMessageDetailsAsync(String messageid, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getInboundMessageDetailsValidateBeforeCall(messageid, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetInboundMessageDetailsRequestBuilder {
        private final String messageid;

        private GetInboundMessageDetailsRequestBuilder(String messageid) {
            this.messageid = messageid;
        }

        /**
         * Build call for getInboundMessageDetails
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getInboundMessageDetailsCall(messageid, _callback);
        }


        /**
         * Execute getInboundMessageDetails request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = getInboundMessageDetailsWithHttpInfo(messageid);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getInboundMessageDetails request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return getInboundMessageDetailsWithHttpInfo(messageid);
        }

        /**
         * Execute getInboundMessageDetails request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return getInboundMessageDetailsAsync(messageid, _callback);
        }
    }

    /**
     * Inbound message details
     * 
     * @param messageid The ID of the message for which to details will be retrieved. (required)
     * @return GetInboundMessageDetailsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public GetInboundMessageDetailsRequestBuilder getInboundMessageDetails(String messageid) throws IllegalArgumentException {
        if (messageid == null) throw new IllegalArgumentException("\"messageid\" is required but got null");
            

        return new GetInboundMessageDetailsRequestBuilder(messageid);
    }
    private okhttp3.Call getMessageClicksCall(String messageid, Integer count, Integer offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound/clicks/{messageid}"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "serverToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMessageClicksValidateBeforeCall(String messageid, Integer count, Integer offset, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling getMessageClicks(Async)");
        }

        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling getMessageClicks(Async)");
        }

        // verify the required parameter 'offset' is set
        if (offset == null) {
            throw new ApiException("Missing the required parameter 'offset' when calling getMessageClicks(Async)");
        }

        return getMessageClicksCall(messageid, count, offset, _callback);

    }


    private ApiResponse<Object> getMessageClicksWithHttpInfo(String messageid, Integer count, Integer offset) throws ApiException {
        okhttp3.Call localVarCall = getMessageClicksValidateBeforeCall(messageid, count, offset, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getMessageClicksAsync(String messageid, Integer count, Integer offset, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMessageClicksValidateBeforeCall(messageid, count, offset, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetMessageClicksRequestBuilder {
        private final String messageid;
        private final Integer count;
        private final Integer offset;

        private GetMessageClicksRequestBuilder(String messageid, Integer count, Integer offset) {
            this.messageid = messageid;
            this.count = count;
            this.offset = offset;
        }

        /**
         * Build call for getMessageClicks
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getMessageClicksCall(messageid, count, offset, _callback);
        }


        /**
         * Execute getMessageClicks request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = getMessageClicksWithHttpInfo(messageid, count, offset);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getMessageClicks request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return getMessageClicksWithHttpInfo(messageid, count, offset);
        }

        /**
         * Execute getMessageClicks request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return getMessageClicksAsync(messageid, count, offset, _callback);
        }
    }

    /**
     * Retrieve Message Clicks
     * 
     * @param messageid The ID of the Outbound Message for which click statistics should be retrieved. (required)
     * @param count Number of message clicks to return per request. Max 500. (required)
     * @param offset Number of messages to skip. (required)
     * @return GetMessageClicksRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public GetMessageClicksRequestBuilder getMessageClicks(String messageid, Integer count, Integer offset) throws IllegalArgumentException {
        if (messageid == null) throw new IllegalArgumentException("\"messageid\" is required but got null");
            

        if (count == null) throw new IllegalArgumentException("\"count\" is required but got null");
        if (offset == null) throw new IllegalArgumentException("\"offset\" is required but got null");
        return new GetMessageClicksRequestBuilder(messageid, count, offset);
    }
    private okhttp3.Call getMessageDumpCall(String messageid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound/{messageid}/dump"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "serverToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMessageDumpValidateBeforeCall(String messageid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling getMessageDump(Async)");
        }

        return getMessageDumpCall(messageid, _callback);

    }


    private ApiResponse<Object> getMessageDumpWithHttpInfo(String messageid) throws ApiException {
        okhttp3.Call localVarCall = getMessageDumpValidateBeforeCall(messageid, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getMessageDumpAsync(String messageid, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMessageDumpValidateBeforeCall(messageid, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetMessageDumpRequestBuilder {
        private final String messageid;

        private GetMessageDumpRequestBuilder(String messageid) {
            this.messageid = messageid;
        }

        /**
         * Build call for getMessageDump
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getMessageDumpCall(messageid, _callback);
        }


        /**
         * Execute getMessageDump request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = getMessageDumpWithHttpInfo(messageid);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getMessageDump request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return getMessageDumpWithHttpInfo(messageid);
        }

        /**
         * Execute getMessageDump request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return getMessageDumpAsync(messageid, _callback);
        }
    }

    /**
     * Outbound message dump
     * 
     * @param messageid The ID of the message for which to retrieve a dump. (required)
     * @return GetMessageDumpRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public GetMessageDumpRequestBuilder getMessageDump(String messageid) throws IllegalArgumentException {
        if (messageid == null) throw new IllegalArgumentException("\"messageid\" is required but got null");
            

        return new GetMessageDumpRequestBuilder(messageid);
    }
    private okhttp3.Call getMessageOpensCall(String messageid, Integer count, Integer offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound/opens/{messageid}"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "serverToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMessageOpensValidateBeforeCall(String messageid, Integer count, Integer offset, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling getMessageOpens(Async)");
        }

        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling getMessageOpens(Async)");
        }

        // verify the required parameter 'offset' is set
        if (offset == null) {
            throw new ApiException("Missing the required parameter 'offset' when calling getMessageOpens(Async)");
        }

        return getMessageOpensCall(messageid, count, offset, _callback);

    }


    private ApiResponse<Object> getMessageOpensWithHttpInfo(String messageid, Integer count, Integer offset) throws ApiException {
        okhttp3.Call localVarCall = getMessageOpensValidateBeforeCall(messageid, count, offset, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getMessageOpensAsync(String messageid, Integer count, Integer offset, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMessageOpensValidateBeforeCall(messageid, count, offset, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetMessageOpensRequestBuilder {
        private final String messageid;
        private final Integer count;
        private final Integer offset;

        private GetMessageOpensRequestBuilder(String messageid, Integer count, Integer offset) {
            this.messageid = messageid;
            this.count = count;
            this.offset = offset;
        }

        /**
         * Build call for getMessageOpens
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getMessageOpensCall(messageid, count, offset, _callback);
        }


        /**
         * Execute getMessageOpens request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = getMessageOpensWithHttpInfo(messageid, count, offset);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getMessageOpens request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return getMessageOpensWithHttpInfo(messageid, count, offset);
        }

        /**
         * Execute getMessageOpens request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return getMessageOpensAsync(messageid, count, offset, _callback);
        }
    }

    /**
     * Retrieve Message Opens
     * 
     * @param messageid The ID of the Outbound Message for which open statistics should be retrieved. (required)
     * @param count Number of message opens to return per request. Max 500. (required)
     * @param offset Number of messages to skip. (required)
     * @return GetMessageOpensRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public GetMessageOpensRequestBuilder getMessageOpens(String messageid, Integer count, Integer offset) throws IllegalArgumentException {
        if (messageid == null) throw new IllegalArgumentException("\"messageid\" is required but got null");
            

        if (count == null) throw new IllegalArgumentException("\"count\" is required but got null");
        if (offset == null) throw new IllegalArgumentException("\"offset\" is required but got null");
        return new GetMessageOpensRequestBuilder(messageid, count, offset);
    }
    private okhttp3.Call getOutboundMessageDetailsCall(String messageid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound/{messageid}/details"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "serverToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getOutboundMessageDetailsValidateBeforeCall(String messageid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling getOutboundMessageDetails(Async)");
        }

        return getOutboundMessageDetailsCall(messageid, _callback);

    }


    private ApiResponse<Object> getOutboundMessageDetailsWithHttpInfo(String messageid) throws ApiException {
        okhttp3.Call localVarCall = getOutboundMessageDetailsValidateBeforeCall(messageid, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getOutboundMessageDetailsAsync(String messageid, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getOutboundMessageDetailsValidateBeforeCall(messageid, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetOutboundMessageDetailsRequestBuilder {
        private final String messageid;

        private GetOutboundMessageDetailsRequestBuilder(String messageid) {
            this.messageid = messageid;
        }

        /**
         * Build call for getOutboundMessageDetails
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getOutboundMessageDetailsCall(messageid, _callback);
        }


        /**
         * Execute getOutboundMessageDetails request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = getOutboundMessageDetailsWithHttpInfo(messageid);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getOutboundMessageDetails request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return getOutboundMessageDetailsWithHttpInfo(messageid);
        }

        /**
         * Execute getOutboundMessageDetails request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return getOutboundMessageDetailsAsync(messageid, _callback);
        }
    }

    /**
     * Outbound message details
     * 
     * @param messageid The ID of the message for which to retrieve details. (required)
     * @return GetOutboundMessageDetailsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public GetOutboundMessageDetailsRequestBuilder getOutboundMessageDetails(String messageid) throws IllegalArgumentException {
        if (messageid == null) throw new IllegalArgumentException("\"messageid\" is required but got null");
            

        return new GetOutboundMessageDetailsRequestBuilder(messageid);
    }
    private okhttp3.Call listOpensForOutboundCall(Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound/opens";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (recipient != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recipient", recipient));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (clientName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("client_name", clientName));
        }

        if (clientCompany != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("client_company", clientCompany));
        }

        if (clientFamily != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("client_family", clientFamily));
        }

        if (osName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("os_name", osName));
        }

        if (osFamily != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("os_family", osFamily));
        }

        if (osCompany != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("os_company", osCompany));
        }

        if (platform != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("platform", platform));
        }

        if (country != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("country", country));
        }

        if (region != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("region", region));
        }

        if (city != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("city", city));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "serverToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listOpensForOutboundValidateBeforeCall(Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling listOpensForOutbound(Async)");
        }

        // verify the required parameter 'offset' is set
        if (offset == null) {
            throw new ApiException("Missing the required parameter 'offset' when calling listOpensForOutbound(Async)");
        }

        return listOpensForOutboundCall(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, _callback);

    }


    private ApiResponse<Object> listOpensForOutboundWithHttpInfo(Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city) throws ApiException {
        okhttp3.Call localVarCall = listOpensForOutboundValidateBeforeCall(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listOpensForOutboundAsync(Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = listOpensForOutboundValidateBeforeCall(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListOpensForOutboundRequestBuilder {
        private final Integer count;
        private final Integer offset;
        private String recipient;
        private String tag;
        private String clientName;
        private String clientCompany;
        private String clientFamily;
        private String osName;
        private String osFamily;
        private String osCompany;
        private String platform;
        private String country;
        private String region;
        private String city;

        private ListOpensForOutboundRequestBuilder(Integer count, Integer offset) {
            this.count = count;
            this.offset = offset;
        }

        /**
         * Set recipient
         * @param recipient Filter by To, Cc, Bcc (optional)
         * @return ListOpensForOutboundRequestBuilder
         */
        public ListOpensForOutboundRequestBuilder recipient(String recipient) {
            this.recipient = recipient;
            return this;
        }
        
        /**
         * Set tag
         * @param tag Filter by tag (optional)
         * @return ListOpensForOutboundRequestBuilder
         */
        public ListOpensForOutboundRequestBuilder tag(String tag) {
            this.tag = tag;
            return this;
        }
        
        /**
         * Set clientName
         * @param clientName Filter by client name, i.e. Outlook, Gmail (optional)
         * @return ListOpensForOutboundRequestBuilder
         */
        public ListOpensForOutboundRequestBuilder clientName(String clientName) {
            this.clientName = clientName;
            return this;
        }
        
        /**
         * Set clientCompany
         * @param clientCompany Filter by company, i.e. Microsoft, Apple, Google (optional)
         * @return ListOpensForOutboundRequestBuilder
         */
        public ListOpensForOutboundRequestBuilder clientCompany(String clientCompany) {
            this.clientCompany = clientCompany;
            return this;
        }
        
        /**
         * Set clientFamily
         * @param clientFamily Filter by client family, i.e. OS X, Chrome (optional)
         * @return ListOpensForOutboundRequestBuilder
         */
        public ListOpensForOutboundRequestBuilder clientFamily(String clientFamily) {
            this.clientFamily = clientFamily;
            return this;
        }
        
        /**
         * Set osName
         * @param osName Filter by full OS name and specific version, i.e. OS X 10.9 Mavericks, Windows 7 (optional)
         * @return ListOpensForOutboundRequestBuilder
         */
        public ListOpensForOutboundRequestBuilder osName(String osName) {
            this.osName = osName;
            return this;
        }
        
        /**
         * Set osFamily
         * @param osFamily Filter by kind of OS used without specific version, i.e. OS X, Windows (optional)
         * @return ListOpensForOutboundRequestBuilder
         */
        public ListOpensForOutboundRequestBuilder osFamily(String osFamily) {
            this.osFamily = osFamily;
            return this;
        }
        
        /**
         * Set osCompany
         * @param osCompany Filter by company which produced the OS, i.e. Apple Computer, Inc., Microsoft Corporation (optional)
         * @return ListOpensForOutboundRequestBuilder
         */
        public ListOpensForOutboundRequestBuilder osCompany(String osCompany) {
            this.osCompany = osCompany;
            return this;
        }
        
        /**
         * Set platform
         * @param platform Filter by platform, i.e. webmail, desktop, mobile (optional)
         * @return ListOpensForOutboundRequestBuilder
         */
        public ListOpensForOutboundRequestBuilder platform(String platform) {
            this.platform = platform;
            return this;
        }
        
        /**
         * Set country
         * @param country Filter by country messages were opened in, i.e. Denmark, Russia (optional)
         * @return ListOpensForOutboundRequestBuilder
         */
        public ListOpensForOutboundRequestBuilder country(String country) {
            this.country = country;
            return this;
        }
        
        /**
         * Set region
         * @param region Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
         * @return ListOpensForOutboundRequestBuilder
         */
        public ListOpensForOutboundRequestBuilder region(String region) {
            this.region = region;
            return this;
        }
        
        /**
         * Set city
         * @param city Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
         * @return ListOpensForOutboundRequestBuilder
         */
        public ListOpensForOutboundRequestBuilder city(String city) {
            this.city = city;
            return this;
        }
        
        /**
         * Build call for listOpensForOutbound
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listOpensForOutboundCall(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, _callback);
        }


        /**
         * Execute listOpensForOutbound request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = listOpensForOutboundWithHttpInfo(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listOpensForOutbound request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return listOpensForOutboundWithHttpInfo(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city);
        }

        /**
         * Execute listOpensForOutbound request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return listOpensForOutboundAsync(count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, _callback);
        }
    }

    /**
     * Opens for all messages
     * 
     * @param count Number of message opens to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @return ListOpensForOutboundRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public ListOpensForOutboundRequestBuilder listOpensForOutbound(Integer count, Integer offset) throws IllegalArgumentException {
        if (count == null) throw new IllegalArgumentException("\"count\" is required but got null");
        if (offset == null) throw new IllegalArgumentException("\"offset\" is required but got null");
        return new ListOpensForOutboundRequestBuilder(count, offset);
    }
    private okhttp3.Call retryInboundMessageCall(String messageid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/inbound/{messageid}/retry"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "serverToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call retryInboundMessageValidateBeforeCall(String messageid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling retryInboundMessage(Async)");
        }

        return retryInboundMessageCall(messageid, _callback);

    }


    private ApiResponse<StandardPostmarkResponse> retryInboundMessageWithHttpInfo(String messageid) throws ApiException {
        okhttp3.Call localVarCall = retryInboundMessageValidateBeforeCall(messageid, null);
        Type localVarReturnType = new TypeToken<StandardPostmarkResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call retryInboundMessageAsync(String messageid, final ApiCallback<StandardPostmarkResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = retryInboundMessageValidateBeforeCall(messageid, _callback);
        Type localVarReturnType = new TypeToken<StandardPostmarkResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class RetryInboundMessageRequestBuilder {
        private final String messageid;

        private RetryInboundMessageRequestBuilder(String messageid) {
            this.messageid = messageid;
        }

        /**
         * Build call for retryInboundMessage
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return retryInboundMessageCall(messageid, _callback);
        }


        /**
         * Execute retryInboundMessage request
         * @return StandardPostmarkResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public StandardPostmarkResponse execute() throws ApiException {
            ApiResponse<StandardPostmarkResponse> localVarResp = retryInboundMessageWithHttpInfo(messageid);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute retryInboundMessage request with HTTP info returned
         * @return ApiResponse&lt;StandardPostmarkResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<StandardPostmarkResponse> executeWithHttpInfo() throws ApiException {
            return retryInboundMessageWithHttpInfo(messageid);
        }

        /**
         * Execute retryInboundMessage request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<StandardPostmarkResponse> _callback) throws ApiException {
            return retryInboundMessageAsync(messageid, _callback);
        }
    }

    /**
     * Retry a failed inbound message for processing
     * 
     * @param messageid The ID of the inbound message on which we should retry processing. (required)
     * @return RetryInboundMessageRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public RetryInboundMessageRequestBuilder retryInboundMessage(String messageid) throws IllegalArgumentException {
        if (messageid == null) throw new IllegalArgumentException("\"messageid\" is required but got null");
            

        return new RetryInboundMessageRequestBuilder(messageid);
    }
    private okhttp3.Call searchInboundMessagesCall(Integer count, Integer offset, String recipient, String fromemail, String subject, String mailboxhash, String tag, String status, LocalDate todate, LocalDate fromdate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/inbound";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (recipient != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recipient", recipient));
        }

        if (fromemail != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromemail", fromemail));
        }

        if (subject != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subject", subject));
        }

        if (mailboxhash != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mailboxhash", mailboxhash));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "serverToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchInboundMessagesValidateBeforeCall(Integer count, Integer offset, String recipient, String fromemail, String subject, String mailboxhash, String tag, String status, LocalDate todate, LocalDate fromdate, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling searchInboundMessages(Async)");
        }

        // verify the required parameter 'offset' is set
        if (offset == null) {
            throw new ApiException("Missing the required parameter 'offset' when calling searchInboundMessages(Async)");
        }

        return searchInboundMessagesCall(count, offset, recipient, fromemail, subject, mailboxhash, tag, status, todate, fromdate, _callback);

    }


    private ApiResponse<InboundSearchResponse> searchInboundMessagesWithHttpInfo(Integer count, Integer offset, String recipient, String fromemail, String subject, String mailboxhash, String tag, String status, LocalDate todate, LocalDate fromdate) throws ApiException {
        okhttp3.Call localVarCall = searchInboundMessagesValidateBeforeCall(count, offset, recipient, fromemail, subject, mailboxhash, tag, status, todate, fromdate, null);
        Type localVarReturnType = new TypeToken<InboundSearchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call searchInboundMessagesAsync(Integer count, Integer offset, String recipient, String fromemail, String subject, String mailboxhash, String tag, String status, LocalDate todate, LocalDate fromdate, final ApiCallback<InboundSearchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchInboundMessagesValidateBeforeCall(count, offset, recipient, fromemail, subject, mailboxhash, tag, status, todate, fromdate, _callback);
        Type localVarReturnType = new TypeToken<InboundSearchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SearchInboundMessagesRequestBuilder {
        private final Integer count;
        private final Integer offset;
        private String recipient;
        private String fromemail;
        private String subject;
        private String mailboxhash;
        private String tag;
        private String status;
        private LocalDate todate;
        private LocalDate fromdate;

        private SearchInboundMessagesRequestBuilder(Integer count, Integer offset) {
            this.count = count;
            this.offset = offset;
        }

        /**
         * Set recipient
         * @param recipient Filter by the user who was receiving the email (optional)
         * @return SearchInboundMessagesRequestBuilder
         */
        public SearchInboundMessagesRequestBuilder recipient(String recipient) {
            this.recipient = recipient;
            return this;
        }
        
        /**
         * Set fromemail
         * @param fromemail Filter by the sender email address (optional)
         * @return SearchInboundMessagesRequestBuilder
         */
        public SearchInboundMessagesRequestBuilder fromemail(String fromemail) {
            this.fromemail = fromemail;
            return this;
        }
        
        /**
         * Set subject
         * @param subject Filter by email subject (optional)
         * @return SearchInboundMessagesRequestBuilder
         */
        public SearchInboundMessagesRequestBuilder subject(String subject) {
            this.subject = subject;
            return this;
        }
        
        /**
         * Set mailboxhash
         * @param mailboxhash Filter by mailboxhash (optional)
         * @return SearchInboundMessagesRequestBuilder
         */
        public SearchInboundMessagesRequestBuilder mailboxhash(String mailboxhash) {
            this.mailboxhash = mailboxhash;
            return this;
        }
        
        /**
         * Set tag
         * @param tag Filter by tag (optional)
         * @return SearchInboundMessagesRequestBuilder
         */
        public SearchInboundMessagesRequestBuilder tag(String tag) {
            this.tag = tag;
            return this;
        }
        
        /**
         * Set status
         * @param status Filter by status (&#x60;blocked&#x60;, &#x60;processed&#x60;, &#x60;queued&#x60;, &#x60;failed&#x60;, &#x60;scheduled&#x60;) (optional)
         * @return SearchInboundMessagesRequestBuilder
         */
        public SearchInboundMessagesRequestBuilder status(String status) {
            this.status = status;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Filter messages up to the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
         * @return SearchInboundMessagesRequestBuilder
         */
        public SearchInboundMessagesRequestBuilder todate(LocalDate todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Filter messages starting from the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
         * @return SearchInboundMessagesRequestBuilder
         */
        public SearchInboundMessagesRequestBuilder fromdate(LocalDate fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Build call for searchInboundMessages
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return searchInboundMessagesCall(count, offset, recipient, fromemail, subject, mailboxhash, tag, status, todate, fromdate, _callback);
        }


        /**
         * Execute searchInboundMessages request
         * @return InboundSearchResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public InboundSearchResponse execute() throws ApiException {
            ApiResponse<InboundSearchResponse> localVarResp = searchInboundMessagesWithHttpInfo(count, offset, recipient, fromemail, subject, mailboxhash, tag, status, todate, fromdate);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute searchInboundMessages request with HTTP info returned
         * @return ApiResponse&lt;InboundSearchResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<InboundSearchResponse> executeWithHttpInfo() throws ApiException {
            return searchInboundMessagesWithHttpInfo(count, offset, recipient, fromemail, subject, mailboxhash, tag, status, todate, fromdate);
        }

        /**
         * Execute searchInboundMessages request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<InboundSearchResponse> _callback) throws ApiException {
            return searchInboundMessagesAsync(count, offset, recipient, fromemail, subject, mailboxhash, tag, status, todate, fromdate, _callback);
        }
    }

    /**
     * Inbound message search
     * 
     * @param count Number of messages to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @return SearchInboundMessagesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public SearchInboundMessagesRequestBuilder searchInboundMessages(Integer count, Integer offset) throws IllegalArgumentException {
        if (count == null) throw new IllegalArgumentException("\"count\" is required but got null");
        if (offset == null) throw new IllegalArgumentException("\"offset\" is required but got null");
        return new SearchInboundMessagesRequestBuilder(count, offset);
    }
    private okhttp3.Call searchOutboundMessagesCall(Integer count, Integer offset, String recipient, String fromemail, String tag, String status, LocalDate todate, LocalDate fromdate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (recipient != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recipient", recipient));
        }

        if (fromemail != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromemail", fromemail));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "serverToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchOutboundMessagesValidateBeforeCall(Integer count, Integer offset, String recipient, String fromemail, String tag, String status, LocalDate todate, LocalDate fromdate, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling searchOutboundMessages(Async)");
        }

        // verify the required parameter 'offset' is set
        if (offset == null) {
            throw new ApiException("Missing the required parameter 'offset' when calling searchOutboundMessages(Async)");
        }

        return searchOutboundMessagesCall(count, offset, recipient, fromemail, tag, status, todate, fromdate, _callback);

    }


    private ApiResponse<OutboundSearchResponse> searchOutboundMessagesWithHttpInfo(Integer count, Integer offset, String recipient, String fromemail, String tag, String status, LocalDate todate, LocalDate fromdate) throws ApiException {
        okhttp3.Call localVarCall = searchOutboundMessagesValidateBeforeCall(count, offset, recipient, fromemail, tag, status, todate, fromdate, null);
        Type localVarReturnType = new TypeToken<OutboundSearchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call searchOutboundMessagesAsync(Integer count, Integer offset, String recipient, String fromemail, String tag, String status, LocalDate todate, LocalDate fromdate, final ApiCallback<OutboundSearchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchOutboundMessagesValidateBeforeCall(count, offset, recipient, fromemail, tag, status, todate, fromdate, _callback);
        Type localVarReturnType = new TypeToken<OutboundSearchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SearchOutboundMessagesRequestBuilder {
        private final Integer count;
        private final Integer offset;
        private String recipient;
        private String fromemail;
        private String tag;
        private String status;
        private LocalDate todate;
        private LocalDate fromdate;

        private SearchOutboundMessagesRequestBuilder(Integer count, Integer offset) {
            this.count = count;
            this.offset = offset;
        }

        /**
         * Set recipient
         * @param recipient Filter by the user who was receiving the email (optional)
         * @return SearchOutboundMessagesRequestBuilder
         */
        public SearchOutboundMessagesRequestBuilder recipient(String recipient) {
            this.recipient = recipient;
            return this;
        }
        
        /**
         * Set fromemail
         * @param fromemail Filter by the sender email address (optional)
         * @return SearchOutboundMessagesRequestBuilder
         */
        public SearchOutboundMessagesRequestBuilder fromemail(String fromemail) {
            this.fromemail = fromemail;
            return this;
        }
        
        /**
         * Set tag
         * @param tag Filter by tag (optional)
         * @return SearchOutboundMessagesRequestBuilder
         */
        public SearchOutboundMessagesRequestBuilder tag(String tag) {
            this.tag = tag;
            return this;
        }
        
        /**
         * Set status
         * @param status Filter by status (&#x60;queued&#x60; or &#x60;sent&#x60;) (optional)
         * @return SearchOutboundMessagesRequestBuilder
         */
        public SearchOutboundMessagesRequestBuilder status(String status) {
            this.status = status;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Filter messages up to the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
         * @return SearchOutboundMessagesRequestBuilder
         */
        public SearchOutboundMessagesRequestBuilder todate(LocalDate todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Filter messages starting from the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
         * @return SearchOutboundMessagesRequestBuilder
         */
        public SearchOutboundMessagesRequestBuilder fromdate(LocalDate fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Build call for searchOutboundMessages
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return searchOutboundMessagesCall(count, offset, recipient, fromemail, tag, status, todate, fromdate, _callback);
        }


        /**
         * Execute searchOutboundMessages request
         * @return OutboundSearchResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public OutboundSearchResponse execute() throws ApiException {
            ApiResponse<OutboundSearchResponse> localVarResp = searchOutboundMessagesWithHttpInfo(count, offset, recipient, fromemail, tag, status, todate, fromdate);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute searchOutboundMessages request with HTTP info returned
         * @return ApiResponse&lt;OutboundSearchResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<OutboundSearchResponse> executeWithHttpInfo() throws ApiException {
            return searchOutboundMessagesWithHttpInfo(count, offset, recipient, fromemail, tag, status, todate, fromdate);
        }

        /**
         * Execute searchOutboundMessages request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<OutboundSearchResponse> _callback) throws ApiException {
            return searchOutboundMessagesAsync(count, offset, recipient, fromemail, tag, status, todate, fromdate, _callback);
        }
    }

    /**
     * Outbound message search
     * 
     * @param count Number of messages to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @return SearchOutboundMessagesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public SearchOutboundMessagesRequestBuilder searchOutboundMessages(Integer count, Integer offset) throws IllegalArgumentException {
        if (count == null) throw new IllegalArgumentException("\"count\" is required but got null");
        if (offset == null) throw new IllegalArgumentException("\"offset\" is required but got null");
        return new SearchOutboundMessagesRequestBuilder(count, offset);
    }
    private okhttp3.Call updateBypassRulesForInboundMessageCall(String messageid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/inbound/{messageid}/bypass"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "serverToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateBypassRulesForInboundMessageValidateBeforeCall(String messageid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling updateBypassRulesForInboundMessage(Async)");
        }

        return updateBypassRulesForInboundMessageCall(messageid, _callback);

    }


    private ApiResponse<StandardPostmarkResponse> updateBypassRulesForInboundMessageWithHttpInfo(String messageid) throws ApiException {
        okhttp3.Call localVarCall = updateBypassRulesForInboundMessageValidateBeforeCall(messageid, null);
        Type localVarReturnType = new TypeToken<StandardPostmarkResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateBypassRulesForInboundMessageAsync(String messageid, final ApiCallback<StandardPostmarkResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateBypassRulesForInboundMessageValidateBeforeCall(messageid, _callback);
        Type localVarReturnType = new TypeToken<StandardPostmarkResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateBypassRulesForInboundMessageRequestBuilder {
        private final String messageid;

        private UpdateBypassRulesForInboundMessageRequestBuilder(String messageid) {
            this.messageid = messageid;
        }

        /**
         * Build call for updateBypassRulesForInboundMessage
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return updateBypassRulesForInboundMessageCall(messageid, _callback);
        }


        /**
         * Execute updateBypassRulesForInboundMessage request
         * @return StandardPostmarkResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public StandardPostmarkResponse execute() throws ApiException {
            ApiResponse<StandardPostmarkResponse> localVarResp = updateBypassRulesForInboundMessageWithHttpInfo(messageid);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateBypassRulesForInboundMessage request with HTTP info returned
         * @return ApiResponse&lt;StandardPostmarkResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<StandardPostmarkResponse> executeWithHttpInfo() throws ApiException {
            return updateBypassRulesForInboundMessageWithHttpInfo(messageid);
        }

        /**
         * Execute updateBypassRulesForInboundMessage request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<StandardPostmarkResponse> _callback) throws ApiException {
            return updateBypassRulesForInboundMessageAsync(messageid, _callback);
        }
    }

    /**
     * Bypass rules for a blocked inbound message
     * 
     * @param messageid The ID of the message which should bypass inbound rules. (required)
     * @return UpdateBypassRulesForInboundMessageRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public UpdateBypassRulesForInboundMessageRequestBuilder updateBypassRulesForInboundMessage(String messageid) throws IllegalArgumentException {
        if (messageid == null) throw new IllegalArgumentException("\"messageid\" is required but got null");
            

        return new UpdateBypassRulesForInboundMessageRequestBuilder(messageid);
    }
}
